import 'dart:math';
import 'dart:ui';

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:paintroid/core/commands/command_implementation/graphic/shape/shape_command.dart';
import 'package:paintroid/core/extensions/path_extension.dart';
import 'package:paintroid/core/json_serialization/converter/offset_converter.dart';
import 'package:paintroid/core/json_serialization/converter/paint_converter.dart';
import 'package:paintroid/core/json_serialization/versioning/serializer_version.dart';
import 'package:paintroid/core/json_serialization/versioning/version_strategy.dart';

part 'star_shape_command.g.dart';

@JsonSerializable()
class StarShapeCommand extends ShapeCommand {
  final int numberOfPoints;
  final double radius;
  final double angle;
  @OffsetConverter()
  final Offset center;

  final int version;
  final String type;

  StarShapeCommand(
    super.paint,
    this.numberOfPoints,
    this.radius,
    this.angle,
    this.center, {
    int? version,
    this.type = SerializerType.STAR_SHAPE_COMMAND,
  }) : version = version ??
            VersionStrategyManager.strategy.getStarShapeCommandVersion();

  Path get path => _getStarPath();

  @override
  void call(Canvas canvas) => canvas.drawPath(path, paint);

  @override
  List<Object?> get props => [paint, numberOfPoints, radius, center];

  @override
  Map<String, dynamic> toJson() => _$StarShapeCommandToJson(this);

  factory StarShapeCommand.fromJson(Map<String, dynamic> json) {
    int version = json['version'] as int;

    switch (version) {
      case Version.v1:
        return _$StarShapeCommandFromJson(json);
      case Version.v2:
      // For different versions of StarShapeCommand the deserialization
      // has to be implemented manually.
      // Autogenerated code can only be used for one version
      default:
        return _$StarShapeCommandFromJson(json);
    }
  }

  Path _getStarPath() {
    final path = Path();
    final innerRadius = radius / 2;
    final angleStep = pi / numberOfPoints;
    for (int i = 0; i < numberOfPoints * 2; i++) {
      final currentRadius = (i % 2 == 0) ? radius : innerRadius;
      final currentAngle = i * angleStep + angle;
      final point = Offset(
        center.dx + currentRadius * cos(currentAngle),
        center.dy + currentRadius * sin(currentAngle),
      );
      i == 0 ? path.moveToOffset(point) : path.lineToOffset(point);
    }
    path.close();
    return path;
  }
}
