// Mocks generated by Mockito 5.4.2 from annotations
// in tools/test/brush_tool_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:typed_data' as _i5;
import 'dart:ui' as _i2;

import 'package:command/command.dart' as _i4;
import 'package:component_library/component_library.dart' as _i3;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakePath_0 extends _i1.SmartFake implements _i2.Path {
  _FakePath_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeRect_1 extends _i1.SmartFake implements _i2.Rect {
  _FakeRect_1(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakePathMetrics_2 extends _i1.SmartFake implements _i2.PathMetrics {
  _FakePathMetrics_2(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeOffset_3 extends _i1.SmartFake implements _i2.Offset {
  _FakeOffset_3(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakePathWithActionHistory_4 extends _i1.SmartFake
    implements _i3.PathWithActionHistory {
  _FakePathWithActionHistory_4(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakePaint_5 extends _i1.SmartFake implements _i2.Paint {
  _FakePaint_5(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeDrawPathCommand_6 extends _i1.SmartFake
    implements _i4.DrawPathCommand {
  _FakeDrawPathCommand_6(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakePictureRecorder_7 extends _i1.SmartFake
    implements _i2.PictureRecorder {
  _FakePictureRecorder_7(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeCanvas_8 extends _i1.SmartFake implements _i2.Canvas {
  _FakeCanvas_8(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [PathWithActionHistory].
///
/// See the documentation for Mockito's code generation for more information.
class MockPathWithActionHistory extends _i1.Mock
    implements _i3.PathWithActionHistory {
  MockPathWithActionHistory() {
    _i1.throwOnMissingStub(this);
  }

  @override
  List<_i3.PathAction> get actions => (super.noSuchMethod(
        Invocation.getter(#actions),
        returnValue: <_i3.PathAction>[],
      ) as List<_i3.PathAction>);

  @override
  _i2.PathFillType get fillType => (super.noSuchMethod(
        Invocation.getter(#fillType),
        returnValue: _i2.PathFillType.nonZero,
      ) as _i2.PathFillType);

  @override
  set fillType(_i2.PathFillType? value) => super.noSuchMethod(
        Invocation.setter(
          #fillType,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  void moveTo(
    double? x,
    double? y,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #moveTo,
          [
            x,
            y,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void lineTo(
    double? x,
    double? y,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #lineTo,
          [
            x,
            y,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void close() => super.noSuchMethod(
        Invocation.method(
          #close,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeMoveTo(
    double? dx,
    double? dy,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeMoveTo,
          [
            dx,
            dy,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeLineTo(
    double? dx,
    double? dy,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeLineTo,
          [
            dx,
            dy,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void quadraticBezierTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #quadraticBezierTo,
          [
            x1,
            y1,
            x2,
            y2,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeQuadraticBezierTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeQuadraticBezierTo,
          [
            x1,
            y1,
            x2,
            y2,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void cubicTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
    double? x3,
    double? y3,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #cubicTo,
          [
            x1,
            y1,
            x2,
            y2,
            x3,
            y3,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeCubicTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
    double? x3,
    double? y3,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeCubicTo,
          [
            x1,
            y1,
            x2,
            y2,
            x3,
            y3,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void conicTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
    double? w,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #conicTo,
          [
            x1,
            y1,
            x2,
            y2,
            w,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeConicTo(
    double? x1,
    double? y1,
    double? x2,
    double? y2,
    double? w,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeConicTo,
          [
            x1,
            y1,
            x2,
            y2,
            w,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void arcTo(
    _i2.Rect? rect,
    double? startAngle,
    double? sweepAngle,
    bool? forceMoveTo,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #arcTo,
          [
            rect,
            startAngle,
            sweepAngle,
            forceMoveTo,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void arcToPoint(
    _i2.Offset? arcEnd, {
    _i2.Radius? radius = _i2.Radius.zero,
    double? rotation = 0.0,
    bool? largeArc = false,
    bool? clockwise = true,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #arcToPoint,
          [arcEnd],
          {
            #radius: radius,
            #rotation: rotation,
            #largeArc: largeArc,
            #clockwise: clockwise,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  void relativeArcToPoint(
    _i2.Offset? arcEndDelta, {
    _i2.Radius? radius = _i2.Radius.zero,
    double? rotation = 0.0,
    bool? largeArc = false,
    bool? clockwise = true,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #relativeArcToPoint,
          [arcEndDelta],
          {
            #radius: radius,
            #rotation: rotation,
            #largeArc: largeArc,
            #clockwise: clockwise,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addRect(_i2.Rect? rect) => super.noSuchMethod(
        Invocation.method(
          #addRect,
          [rect],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addOval(_i2.Rect? oval) => super.noSuchMethod(
        Invocation.method(
          #addOval,
          [oval],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addArc(
    _i2.Rect? oval,
    double? startAngle,
    double? sweepAngle,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #addArc,
          [
            oval,
            startAngle,
            sweepAngle,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addPolygon(
    List<_i2.Offset>? points,
    bool? close,
  ) =>
      super.noSuchMethod(
        Invocation.method(
          #addPolygon,
          [
            points,
            close,
          ],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addRRect(_i2.RRect? rrect) => super.noSuchMethod(
        Invocation.method(
          #addRRect,
          [rrect],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void addPath(
    _i2.Path? path,
    _i2.Offset? offset, {
    _i5.Float64List? matrix4,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #addPath,
          [
            path,
            offset,
          ],
          {#matrix4: matrix4},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void extendWithPath(
    _i2.Path? path,
    _i2.Offset? offset, {
    _i5.Float64List? matrix4,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #extendWithPath,
          [
            path,
            offset,
          ],
          {#matrix4: matrix4},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void reset() => super.noSuchMethod(
        Invocation.method(
          #reset,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  bool contains(_i2.Offset? point) => (super.noSuchMethod(
        Invocation.method(
          #contains,
          [point],
        ),
        returnValue: false,
      ) as bool);

  @override
  _i2.Path shift(_i2.Offset? offset) => (super.noSuchMethod(
        Invocation.method(
          #shift,
          [offset],
        ),
        returnValue: _FakePath_0(
          this,
          Invocation.method(
            #shift,
            [offset],
          ),
        ),
      ) as _i2.Path);

  @override
  _i2.Path transform(_i5.Float64List? matrix4) => (super.noSuchMethod(
        Invocation.method(
          #transform,
          [matrix4],
        ),
        returnValue: _FakePath_0(
          this,
          Invocation.method(
            #transform,
            [matrix4],
          ),
        ),
      ) as _i2.Path);

  @override
  _i2.Rect getBounds() => (super.noSuchMethod(
        Invocation.method(
          #getBounds,
          [],
        ),
        returnValue: _FakeRect_1(
          this,
          Invocation.method(
            #getBounds,
            [],
          ),
        ),
      ) as _i2.Rect);

  @override
  _i2.PathMetrics computeMetrics({bool? forceClosed = false}) =>
      (super.noSuchMethod(
        Invocation.method(
          #computeMetrics,
          [],
          {#forceClosed: forceClosed},
        ),
        returnValue: _FakePathMetrics_2(
          this,
          Invocation.method(
            #computeMetrics,
            [],
            {#forceClosed: forceClosed},
          ),
        ),
      ) as _i2.PathMetrics);
}

/// A class which mocks [Offset].
///
/// See the documentation for Mockito's code generation for more information.
class MockOffset extends _i1.Mock implements _i2.Offset {
  MockOffset() {
    _i1.throwOnMissingStub(this);
  }

  @override
  double get dx => (super.noSuchMethod(
        Invocation.getter(#dx),
        returnValue: 0.0,
      ) as double);

  @override
  double get dy => (super.noSuchMethod(
        Invocation.getter(#dy),
        returnValue: 0.0,
      ) as double);

  @override
  double get distance => (super.noSuchMethod(
        Invocation.getter(#distance),
        returnValue: 0.0,
      ) as double);

  @override
  double get distanceSquared => (super.noSuchMethod(
        Invocation.getter(#distanceSquared),
        returnValue: 0.0,
      ) as double);

  @override
  double get direction => (super.noSuchMethod(
        Invocation.getter(#direction),
        returnValue: 0.0,
      ) as double);

  @override
  bool get isInfinite => (super.noSuchMethod(
        Invocation.getter(#isInfinite),
        returnValue: false,
      ) as bool);

  @override
  bool get isFinite => (super.noSuchMethod(
        Invocation.getter(#isFinite),
        returnValue: false,
      ) as bool);

  @override
  _i2.Offset scale(
    double? scaleX,
    double? scaleY,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #scale,
          [
            scaleX,
            scaleY,
          ],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #scale,
            [
              scaleX,
              scaleY,
            ],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset translate(
    double? translateX,
    double? translateY,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #translate,
          [
            translateX,
            translateY,
          ],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #translate,
            [
              translateX,
              translateY,
            ],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator -() => (super.noSuchMethod(
        Invocation.method(
          #-,
          [],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #-,
            [],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator -(_i2.Offset? other) => (super.noSuchMethod(
        Invocation.method(
          #-,
          [other],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #-,
            [other],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator +(_i2.Offset? other) => (super.noSuchMethod(
        Invocation.method(
          #+,
          [other],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #+,
            [other],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator *(double? operand) => (super.noSuchMethod(
        Invocation.method(
          #*,
          [operand],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #*,
            [operand],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator /(double? operand) => (super.noSuchMethod(
        Invocation.method(
          #/,
          [operand],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #/,
            [operand],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator ~/(double? operand) => (super.noSuchMethod(
        Invocation.method(
          #~/,
          [operand],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #~/,
            [operand],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Offset operator %(double? operand) => (super.noSuchMethod(
        Invocation.method(
          #%,
          [operand],
        ),
        returnValue: _FakeOffset_3(
          this,
          Invocation.method(
            #%,
            [operand],
          ),
        ),
      ) as _i2.Offset);

  @override
  _i2.Rect operator &(_i2.Size? other) => (super.noSuchMethod(
        Invocation.method(
          #&,
          [other],
        ),
        returnValue: _FakeRect_1(
          this,
          Invocation.method(
            #&,
            [other],
          ),
        ),
      ) as _i2.Rect);

  @override
  bool operator <(_i2.OffsetBase? other) => (super.noSuchMethod(
        Invocation.method(
          #<,
          [other],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool operator <=(_i2.OffsetBase? other) => (super.noSuchMethod(
        Invocation.method(
          #<=,
          [other],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool operator >(_i2.OffsetBase? other) => (super.noSuchMethod(
        Invocation.method(
          #>,
          [other],
        ),
        returnValue: false,
      ) as bool);

  @override
  bool operator >=(_i2.OffsetBase? other) => (super.noSuchMethod(
        Invocation.method(
          #>=,
          [other],
        ),
        returnValue: false,
      ) as bool);
}

/// A class which mocks [DrawPathCommand].
///
/// See the documentation for Mockito's code generation for more information.
class MockDrawPathCommand extends _i1.Mock implements _i4.DrawPathCommand {
  MockDrawPathCommand() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.PathWithActionHistory get path => (super.noSuchMethod(
        Invocation.getter(#path),
        returnValue: _FakePathWithActionHistory_4(
          this,
          Invocation.getter(#path),
        ),
      ) as _i3.PathWithActionHistory);

  @override
  List<Object?> get props => (super.noSuchMethod(
        Invocation.getter(#props),
        returnValue: <Object?>[],
      ) as List<Object?>);

  @override
  _i2.Paint get paint => (super.noSuchMethod(
        Invocation.getter(#paint),
        returnValue: _FakePaint_5(
          this,
          Invocation.getter(#paint),
        ),
      ) as _i2.Paint);

  @override
  void call(_i2.Canvas? canvas) => super.noSuchMethod(
        Invocation.method(
          #call,
          [canvas],
        ),
        returnValueForMissingStub: null,
      );
}

/// A class which mocks [CommandManager].
///
/// See the documentation for Mockito's code generation for more information.
class MockCommandManager extends _i1.Mock implements _i4.CommandManager {
  MockCommandManager() {
    _i1.throwOnMissingStub(this);
  }

  @override
  Iterable<_i4.Command> get history => (super.noSuchMethod(
        Invocation.getter(#history),
        returnValue: <_i4.Command>[],
      ) as Iterable<_i4.Command>);

  @override
  int get count => (super.noSuchMethod(
        Invocation.getter(#count),
        returnValue: 0,
      ) as int);

  @override
  void addGraphicCommand(_i4.GraphicCommand? command) => super.noSuchMethod(
        Invocation.method(
          #addGraphicCommand,
          [command],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void executeLastCommand(_i2.Canvas? canvas) => super.noSuchMethod(
        Invocation.method(
          #executeLastCommand,
          [canvas],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void executeAllCommands(_i2.Canvas? canvas) => super.noSuchMethod(
        Invocation.method(
          #executeAllCommands,
          [canvas],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void discardLastCommand() => super.noSuchMethod(
        Invocation.method(
          #discardLastCommand,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void clearHistory({Iterable<_i4.Command>? newCommands}) => super.noSuchMethod(
        Invocation.method(
          #clearHistory,
          [],
          {#newCommands: newCommands},
        ),
        returnValueForMissingStub: null,
      );
}

/// A class which mocks [CommandFactory].
///
/// See the documentation for Mockito's code generation for more information.
class MockCommandFactory extends _i1.Mock implements _i4.CommandFactory {
  MockCommandFactory() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i4.DrawPathCommand createDrawPathCommand(
    _i3.PathWithActionHistory? path,
    _i2.Paint? paint,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #createDrawPathCommand,
          [
            path,
            paint,
          ],
        ),
        returnValue: _FakeDrawPathCommand_6(
          this,
          Invocation.method(
            #createDrawPathCommand,
            [
              path,
              paint,
            ],
          ),
        ),
      ) as _i4.DrawPathCommand);
}

/// A class which mocks [GraphicFactory].
///
/// See the documentation for Mockito's code generation for more information.
class MockGraphicFactory extends _i1.Mock implements _i3.GraphicFactory {
  MockGraphicFactory() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.Paint createPaint() => (super.noSuchMethod(
        Invocation.method(
          #createPaint,
          [],
        ),
        returnValue: _FakePaint_5(
          this,
          Invocation.method(
            #createPaint,
            [],
          ),
        ),
      ) as _i2.Paint);

  @override
  _i3.PathWithActionHistory createPathWithActionHistory() =>
      (super.noSuchMethod(
        Invocation.method(
          #createPathWithActionHistory,
          [],
        ),
        returnValue: _FakePathWithActionHistory_4(
          this,
          Invocation.method(
            #createPathWithActionHistory,
            [],
          ),
        ),
      ) as _i3.PathWithActionHistory);

  @override
  _i2.PictureRecorder createPictureRecorder() => (super.noSuchMethod(
        Invocation.method(
          #createPictureRecorder,
          [],
        ),
        returnValue: _FakePictureRecorder_7(
          this,
          Invocation.method(
            #createPictureRecorder,
            [],
          ),
        ),
      ) as _i2.PictureRecorder);

  @override
  _i2.Canvas createCanvasWithRecorder(_i2.PictureRecorder? recorder) =>
      (super.noSuchMethod(
        Invocation.method(
          #createCanvasWithRecorder,
          [recorder],
        ),
        returnValue: _FakeCanvas_8(
          this,
          Invocation.method(
            #createCanvasWithRecorder,
            [recorder],
          ),
        ),
      ) as _i2.Canvas);

  @override
  _i2.Paint copyPaint(_i2.Paint? original) => (super.noSuchMethod(
        Invocation.method(
          #copyPaint,
          [original],
        ),
        returnValue: _FakePaint_5(
          this,
          Invocation.method(
            #copyPaint,
            [original],
          ),
        ),
      ) as _i2.Paint);
}
